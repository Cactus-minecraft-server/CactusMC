[1mdiff --git a/Cargo.lock b/Cargo.lock[m
[1mindex fe54528..dda55dd 100644[m
[1m--- a/Cargo.lock[m
[1m+++ b/Cargo.lock[m
[36m@@ -225,6 +225,26 @@[m [mversion = "1.2.0"[m
 source = "registry+https://github.com/rust-lang/crates.io-index"[m
 checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"[m
 [m
[32m+[m[32m[[package]][m
[32m+[m[32mname = "serde"[m
[32m+[m[32mversion = "1.0.208"[m
[32m+[m[32msource = "registry+https://github.com/rust-lang/crates.io-index"[m
[32m+[m[32mchecksum = "cff085d2cb684faa248efb494c39b68e522822ac0de72ccf08109abde717cfb2"[m
[32m+[m[32mdependencies = [[m
[32m+[m[32m "serde_derive",[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32m[[package]][m
[32m+[m[32mname = "serde_derive"[m
[32m+[m[32mversion = "1.0.208"[m
[32m+[m[32msource = "registry+https://github.com/rust-lang/crates.io-index"[m
[32m+[m[32mchecksum = "24008e81ff7613ed8e5ba0cfaf24e2c2f1e5b8a0495711e44fcd4882fca62bcf"[m
[32m+[m[32mdependencies = [[m
[32m+[m[32m "proc-macro2",[m
[32m+[m[32m "quote",[m
[32m+[m[32m "syn",[m
[32m+[m[32m][m
[32m+[m
 [[package]][m
 name = "server"[m
 version = "0.1.0"[m
[36m@@ -232,6 +252,7 @@[m [mdependencies = [[m
  "colored",[m
  "dot-properties",[m
  "integer-encoding",[m
[32m+[m[32m "serde",[m
  "thiserror",[m
  "tokio",[m
 ][m
[1mdiff --git a/Cargo.toml b/Cargo.toml[m
[1mindex 5b9327d..cb7a21f 100644[m
[1m--- a/Cargo.toml[m
[1m+++ b/Cargo.toml[m
[36m@@ -9,3 +9,5 @@[m [mcolored = "2.1.0"[m
 integer-encoding = "4.0.2"[m
 tokio = { version = "1.39.3", features = ["full"] }[m
 thiserror = "1.0.63"[m
[32m+[m[32mserde = "1.0.208"[m
[41m+[m
[1mdiff --git a/TODO.md b/TODO.md[m
[1mindex 5c35e53..f178eaf 100644[m
[1m--- a/TODO.md[m
[1m+++ b/TODO.md[m
[36m@@ -1,6 +1,6 @@[m
 # SLP[m
 [m
[31m-- [ ] Parse server.properties file for info[m
[32m+[m[32m- [X] Parse server.properties file for info[m
 [m
 - [ ] Globals like server version[m
 [m
[1mdiff --git a/src/config/mod.rs b/src/config/mod.rs[m
[1mindex b954cca..c9e1eed 100644[m
[1m--- a/src/config/mod.rs[m
[1m+++ b/src/config/mod.rs[m
[36m@@ -105,7 +105,7 @@[m [mpub struct Settings {[m
 }[m
 [m
 pub fn read(filepath: &Path) -> std::io::Result<Properties> {[m
[31m-    //do not forget to remove the pub when function new is finish![m
[32m+[m[32m    //do not forget to remove the pub while "new" function  is finish![m
     let file = File::open(filepath)?;[m
     let mut reader = BufReader::new(file);[m
     read_properties(&mut reader).map_err(|e| Error::new(ErrorKind::Other, e.to_string()))[m
[1mdiff --git a/src/consts/mod.rs b/src/consts/mod.rs[m
[1mindex bcf72d1..9ddc9d0 100644[m
[1m--- a/src/consts/mod.rs[m
[1m+++ b/src/consts/mod.rs[m
[36m@@ -5,7 +5,7 @@[m
 [m
 /// Module where we store information relevant to the Minecraft server.[m
 pub mod minecraft {[m
[31m-    pub const VERSION: &'static str = "1.21"; // I just change the game version to 1.20.6 -> 1.21[m
[32m+[m[32m    pub const VERSION: &'static str = "1.21.1"; //upgrade to 1.21.1 cuz wiki.vg is up to date[m
     pub const PROTOCOL_VERSION: usize = 767;[m
 }[m
 [m
[1mdiff --git a/src/net/mod.rs b/src/net/mod.rs[m
[1mindex a885225..e887244 100644[m
[1m--- a/src/net/mod.rs[m
[1m+++ b/src/net/mod.rs[m
[36m@@ -1,11 +1,15 @@[m
 //! This module manages the TCP server and how/where the packets are managed/sent.[m
 [m
 use crate::config;[m
[32m+[m[32muse crate::packet::utils::print;[m
[32m+[m[32muse crate::packet::Packet;[m
 use std::net::SocketAddr;[m
 use tokio::io::{AsyncReadExt, AsyncWriteExt};[m
 use tokio::net::TcpListener;[m
 use tokio::net::TcpStream;[m
 [m
[32m+[m[32m// All data sent over the network (except for VarInt and VarLong)[m
[32m+[m
 // TODO: Logging.[m
 [m
 /// Global buffer/packet size allocation when allocating for a new packet buffer (in bytes).[m
[36m@@ -20,44 +24,55 @@[m [mpub async fn listen() -> Result<(), Box<dyn std::error::Error>> {[m
 [m
     loop {[m
         let (socket, addr) = listener.accept().await?;[m
[31m-        handle_connection(socket, addr).await;[m
[32m+[m[32m        tokio::spawn(async move {[m
[32m+[m[32m            if let Err(e) = handle_connection(socket, addr).await {[m
[32m+[m[32m                eprintln!("Error handling connection from {}: {}", addr, e);[m
[32m+[m[32m            }[m
[32m+[m[32m        });[m
     }[m
 }[m
 [m
[32m+[m[32menum ConnectionState {[m
[32m+[m[32m    Handshake,[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstruct Connection {}[m
[32m+[m
 /// This function handles each connection.[m
[31m-async fn handle_connection(mut socket: TcpStream, addr: SocketAddr) {[m
[31m-    tokio::spawn(async move {[m
[31m-        println!("New connection: {}", addr);[m
[31m-[m
[31m-        // TODO: Maybe have a bigger/dynamic buffer.[m
[31m-        let mut buf = [0; BUFFER_SIZE];[m
[31m-[m
[31m-        loop {[m
[31m-            let n = match socket.read(&mut buf).await {[m
[31m-                Ok(n) if n == 0 => return,[m
[31m-                Ok(n) => n,[m
[31m-                Err(e) => {[m
[31m-                    eprintln!("Failed to read from socket: {}", e);[m
[31m-                    return;[m
[31m-                }[m
[31m-            };[m
[31m-[m
[31m-            if let Err(e) = socket.write_all(&buf[0..n]).await {[m
[31m-                eprintln!("Failed to write to socket: {}", e);[m
[31m-                return;[m
[31m-            }[m
[32m+[m[32masync fn handle_connection([m
[32m+[m[32m    mut socket: TcpStream,[m
[32m+[m[32m    addr: SocketAddr,[m
[32m+[m[32m) -> Result<(), Box<dyn std::error::Error>> {[m
[32m+[m[32m    println!("New connection: {}", addr);[m
[32m+[m[32m    // TODO: Maybe have a bigger/dynamic buffer?[m
[32m+[m[32m    let mut buf = [0; BUFFER_SIZE];[m
 [m
[31m-            // handle the packet![m
[31m-            handle_packet(buf, n).await;[m
[32m+[m[32m    loop {[m
[32m+[m[32m        let n = socket.read(&mut buf).await?;[m
[32m+[m[32m        if n == 0 {[m
[32m+[m[32m            println!("Connection closed: {}", addr);[m
[32m+[m[32m            return Ok(());[m
         }[m
[31m-    });[m
[32m+[m
[32m+[m[32m        let response = handle_packet(&buf[..n]).await;[m
[32m+[m[32m        socket.write_all(&response).await?;[m
[32m+[m[32m    }[m
 }[m
 [m
 /// This function takes the buffer, an array of bytes,[m
[31m-async fn handle_packet(buffer: [u8; BUFFER_SIZE], length: usize) {[m
[31m-    println!("Reveived packet of length: {length}: ");[m
[32m+[m[32masync fn handle_packet(buffer: &[u8]) -> Vec<u8> {[m
[32m+[m[32m    let packet = Packet::new(buffer);[m
[32m+[m[32m    print::blue(&format!("NEW PACKET ({}): {}", packet.len(), packet));[m
 [m
[31m-    for (idx, byte) in buffer.iter().enumerate().take(length) {[m
[31m-        println!("{idx}: {byte}");[m
[31m-    }[m
[32m+[m[32m    let packet_id = packet.get_id().as_ref().expect("Could not get packet ID!");[m
[32m+[m[32m    println!("PACKET ID: {}", packet_id.get_value());[m
[32m+[m
[32m+[m[32m    // create a response[m
[32m+[m
[32m+[m[32m    let mut response = Vec::new();[m
[32m+[m[32m    response.extend_from_slice(b"Received: ");[m
[32m+[m[32m    response.extend_from_slice(buffer);[m
[32m+[m
[32m+[m[32m    print!("\n\n\n");[m
[32m+[m[32m    response[m
 }[m
[1mdiff --git a/src/packet/codec.rs b/src/packet/codec.rs[m
[1mindex 09b7bec..42da550 100644[m
[1m--- a/src/packet/codec.rs[m
[1m+++ b/src/packet/codec.rs[m
[36m@@ -36,4 +36,32 @@[m [mpub mod decode {[m
     }[m
 }[m
 [m
[31m-// TODO: Write unit-tests for this file, it shouldn't be very difficult.[m
[32m+[m[32m// TODO: Finish writing unit-tests[m
[32m+[m
[32m+[m[32m#[cfg(test)][m
[32m+[m[32mmod tests {[m
[32m+[m[32m    use std::collections::HashMap;[m
[32m+[m
[32m+[m[32m    use super::*;[m
[32m+[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn test_encode_varint() {[m
[32m+[m[32m        let mut values: HashMap<i32, Vec<u8>> = HashMap::new();[m
[32m+[m
[32m+[m[32m        values.insert(0, vec![0x00]);[m
[32m+[m[32m        values.insert(1, vec![0x01]);[m
[32m+[m[32m        values.insert(127, vec![0x7F]);[m
[32m+[m[32m        values.insert(128, vec![0x80, 0x01]);[m
[32m+[m[32m        values.insert(255, vec![0xFF, 0x01]);[m
[32m+[m[32m        values.insert(25565, vec![0xDD, 0xC7, 0x01]);[m
[32m+[m[32m        values.insert(2097151, vec![0xFF, 0xFF, 0x7F]);[m
[32m+[m[32m        values.insert(2147483647, vec![0xFF, 0xFF, 0xFF, 0xFF, 0x07]);[m
[32m+[m[32m        values.insert(-1, vec![0xff, 0xff, 0xff, 0xff, 0x0f]);[m
[32m+[m[32m        values.insert(-2147483648, vec![0x80, 0x80, 0x80, 0x80, 0x08]);[m
[32m+[m
[32m+[m[32m        for (value, bytes) in values {[m
[32m+[m[32m            let encoded_varint: Vec<u8> = encode::varint(value).expect("Failed to encode varint");[m
[32m+[m[32m            assert_eq!(encoded_varint, bytes);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/src/packet/mod.rs b/src/packet/mod.rs[m
[1mindex 00f8f95..c3385f8 100644[m
[1m--- a/src/packet/mod.rs[m
[1m+++ b/src/packet/mod.rs[m
[36m@@ -6,6 +6,7 @@[m [mpub mod utils;[m
 [m
 use core::fmt;[m
 [m
[32m+[m
 use thiserror::Error;[m
 [m
 // TODO: contains abstraction over a Minecraft packet. And helper functions in adjacent files like[m
[36m@@ -13,7 +14,6 @@[m [muse thiserror::Error;[m
 [m
 /// An abstraction for a Minecraft packet.[m
 pub struct Packet<'a> {[m
[31m-    length: usize,[m
     /// An ID that each Packet has, varint-decoded.[m
     id: Result<PacketId, PacketError>,[m
     /// The raw bytes making the packet.[m
[36m@@ -31,14 +31,26 @@[m [mpub struct Packet<'a> {[m
 [m
 impl<'a> Packet<'a> {[m
     /// Initalizes a new `Packet` with an empty `data` buffer.[m
[31m-    pub fn new(data: &'a [u8], length: usize) -> Self {[m
[32m+[m[32m    pub fn new(data: &'a [u8]) -> Self {[m
         Self {[m
[31m-            length,[m
             id: PacketId::try_from(data),[m
             data,[m
         }[m
     }[m
 [m
[32m+[m[32m    pub fn encode_varint(value: i32) -> Vec<u8> {[m
[32m+[m[32m        let mut buffer = Vec::new();[m
[32m+[m[32m        let mut v = value as u32; //use u32 (chatgpt) cuz varint use this ?[m
[32m+[m
[32m+[m[32m        while v >= 0x80 {[m
[32m+[m[32m            buffer.push((v as u8) | 0x80);[m
[32m+[m[32m            v >>= 7;[m
[32m+[m[32m        }[m
[32m+[m[32m        buffer.push(v as u8);[m
[32m+[m
[32m+[m[32m        buffer[m
[32m+[m[32m    }[m
[32m+[m
     /// Returns a reference to the packet `data`.[m
     pub fn get_data(&self) -> &[u8] {[m
         self.data[m
[36m@@ -51,10 +63,6 @@[m [mimpl<'a> Packet<'a> {[m
 [m
     /// Returns the number of elements inside `data`.[m
     pub fn len(&self) -> usize {[m
[31m-        self.length[m
[31m-    }[m
[31m-[m
[31m-    pub fn len_data(&self) -> usize {[m
         self.data.len()[m
     }[m
 }[m
[36m@@ -67,7 +75,6 @@[m [mimpl<'a> Packet<'a> {[m
 impl<'a> Default for Packet<'a> {[m
     fn default() -> Self {[m
         Self {[m
[31m-            length: 0,[m
             id: Ok(PacketId::default()),[m
             data: &[],[m
         }[m
[36m@@ -86,13 +93,14 @@[m [mpub enum PacketType {[m
     Todo,[m
 }[m
 [m
[32m+[m[32m// TODO: Implement std::Display. Print packet type (if found) and value.[m
 pub struct PacketId {[m
     id: i32,[m
     id_length: usize,[m
 }[m
 [m
 impl PacketId {[m
[31m-    pub fn get_id(&self) -> i32 {[m
[32m+[m[32m    pub fn get_value(&self) -> i32 {[m
         self.id[m
     }[m
 [m
[36m@@ -177,18 +185,22 @@[m [mpub enum PacketError {[m
 [m
 #[cfg(test)][m
 mod tests {[m
[32m+[m
[32m+[m
     use super::*;[m
 [m
     #[test][m
     fn test_packet_creation() {[m
[31m-        let data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];[m
[31m-        let length = 4;[m
[31m-[m
[31m-        let packet = Packet::new(&data, length);[m
[31m-[m
[31m-        let data = [0; 1024];[m
[31m-        let length = 1024;[m
[31m-[m
[32m+[m[32m        let data = [1, 2, 3, 4, 5];[m
[32m+[m[32m        let packet = Packet::new(&data);[m
         assert_eq!(packet.data, data);[m
     }[m
[32m+[m[32m    #[test][m
[32m+[m
[32m+[m[32m    fn test_encode_varint() {[m
[32m+[m[32m        let expected_varint: Vec<u8> = vec![210, 6]; //850 in varint[m
[32m+[m[32m        let returned_varint = Packet::encode_varint(850); // call the function[m
[32m+[m[32m        assert_eq!(expected_varint, returned_varint);[m
[32m+[m[32m    }[m
[32m+[m
 }[m
[1mdiff --git a/src/packet/utils.rs b/src/packet/utils.rs[m
[1mindex 077afd8..1641c79 100644[m
[1m--- a/src/packet/utils.rs[m
[1m+++ b/src/packet/utils.rs[m
[36m@@ -14,3 +14,19 @@[m [mpub fn get_bin_repr(data: &[u8]) -> String {[m
         .collect::<Vec<String>>()[m
         .join(" ")[m
 }[m
[32m+[m
[32m+[m[32mpub mod print {[m
[32m+[m[32m    use colored::Colorize;[m
[32m+[m
[32m+[m[32m    pub fn red(msg: &str) {[m
[32m+[m[32m        println!("{}", msg.red());[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn green(msg: &str) {[m
[32m+[m[32m        println!("{}", msg.bright_green());[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn blue(msg: &str) {[m
[32m+[m[32m        println!("{}", msg.bright_blue());[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
