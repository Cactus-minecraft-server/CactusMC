//! This module abstracts away a Minecraft packet, so that it can be used in a simple and
//! standardized way.

pub mod codec;
pub mod utils;

// TODO: contains abstraction over a Minecraft packet. And helper functions in adjacent files like
// VarInt, VarLong, String, ... encoding.

/// An abstraction for a Minecraft packet.
pub struct Packet {
    /// Length of the packet in bytes, varint-decoded.
    length: usize,
    /// An ID that each Packet has, varint-decoded.
    id: PacketId,
    /// The raw bytes making the packet.
    data: Vec<u8>,
}

// TODO: Implement some functions or overload the `new()` method to initialize the packet with
// actual bytes.

// TODO: Implement printing functions to see the bytes in hexadecimal in order and in the reverse
// order.

// TODO: Implement `Iterator` trait to iterate over the packet's bytes in order to then implement
// encoding/decoding functions for VarInts and such.

impl Packet {
    /// Initalizes a new `Packet` with an empty `data` buffer.
    pub fn new() -> Self {
        Self { data: Vec::new() }
    }

    /// Returns a reference to `data`
    pub fn get_raw_bytes(&self) -> &Vec<u8> {
        &self.data
    }

    /// A simple "mock" function
    pub fn count_bytes(&self) -> usize {
        self.data.len()
    }
}

impl Default for Packet {
    fn default() -> Self {
        Self { data: Vec::new() }
    }
}

enum PacketType {
    TODO,
}

pub struct PacketId {
    id: i32,
    id_length: usize
}

impl PacketId {
    pub fn new(packet: &Packet) -> Option<Self> {
        todo!()
    }

    fn get_id_from_packet(data: &[u8]) -> i32 {
        let id = codec::decode::varint(data)
    }
    /// Returns the "type" of the packet. An enum representing what the packet is, like connecting
    /// to the server or opening a container in front of the player.
    ///
    /// We return a `Option<PacketType>` because the packet could be unidentified (Rust already has
    /// Option<T>, so we're not adding a None variant to PacketType.)
    pub fn get_type() -> Option<PacketType> {
        todo!()
    }
}
